using System;
using System.Collections.Generic;
using System.Linq;
using Goliath.Data.Collections;
using Goliath.Data.DataAccess;
using Goliath.Data.Diagnostics;
using Goliath.Data.Mapping;
using Goliath.Data.Providers;
using Goliath.Data.Utils;

namespace Goliath.Data.Sql
{
    

    /// <summary>
    /// 
    /// </summary>
    public sealed class SqlWorker : ISqlWorker
    {
        readonly SqlDialect dialect;
        readonly EntityAccessorStore EntityAccessorStore;
        static ILogger logger;
        readonly ITypeConverterStore typeConverterStore;

        static SqlWorker()
        {
            logger = Logger.GetLogger(typeof(SqlWorker));
        }

        internal SqlWorker(SqlDialect dialect, EntityAccessorStore EntityAccessorStore, ITypeConverterStore typeConverterStore)
        {
            if (dialect == null)
                throw new ArgumentNullException("dialect");
            if (EntityAccessorStore == null)
                throw new ArgumentNullException("EntityAccessorStore");

            this.dialect = dialect;
            this.EntityAccessorStore = EntityAccessorStore;
            this.typeConverterStore = typeConverterStore;
        }

        internal static SelectSqlBuilder BuildSelectSql(EntityMap entityMap, SqlDialect dialect, IDbAccess dataAccess, PropertyQueryParam[] filters)
        {
            var queryBuilder = new SelectSqlBuilder(dialect, entityMap);
            if ((filters != null) && (filters.Length > 0))
            {
                for (int i = 0; i < filters.Length; i++)
                {
                    var prop = entityMap[filters[i].PropertyName];
                    if (prop == null)
                        throw new MappingException(string.Format("Property {0} not found in mapped entity {1}", filters[i].PropertyName, entityMap.FullName));

                    filters[i].SetParameterName(prop.ColumnName, entityMap.TableAlias);
                    var w = new WhereStatement(prop.ColumnName)
                    {
                        Operator = filters[i].ComparisonOperator,
                        PostOperator = filters[i].PostOperator,
                        RightOperand = new StringOperand(dialect.CreateParameterName(ParameterNameBuilderHelper.ColumnQueryName(prop.ColumnName, entityMap.TableAlias)))
                    };

                    queryBuilder.Where(w);
                }
            }

            return queryBuilder;
        }

        #region Inserts

        internal Dictionary<string, KeyGenOperationInfo> GeneratePksForInsert(object entity, EntityMap entityMap, EntityAccessor getSetInfo)
        {
            Dictionary<string, KeyGenOperationInfo> keygenerationOperations = new Dictionary<string, KeyGenOperationInfo>();

            if (entityMap.PrimaryKey != null)
            {
                foreach (var pk in entityMap.PrimaryKey.Keys)
                {
                    if (pk.KeyGenerator == null)
                    {
                        continue;
                        //throw new MappingException(string.Format("No key generator specified for {0} for mapped entity {1}", pk.Key.PropertyName, entityMap.FullName));
                    }

                    if (!pk.Key.IsAutoGenerated)
                    {
                        PropertyAccessor pInfo;
                        if (getSetInfo.Properties.TryGetValue(pk.Key.PropertyName, out pInfo) && pk.CanGenerateKey(pInfo, entity, typeConverterStore))
                        {
                            SqlOperationPriority priority;
                            var id = pk.KeyGenerator.GenerateKey(dialect, entityMap, pk.Key.PropertyName, out priority);
                            pInfo.SetMethod(entity, id);
                        }
                    }
                    else
                    {
                        SqlOperationPriority priority;
                        string genText = pk.KeyGenerator.GenerateKey(dialect, entityMap, pk.Key.PropertyName, out priority).ToString();
                        SqlOperationInfo genOper = new SqlOperationInfo() { CommandType = SqlStatementType.Select, Parameters = new QueryParam[] { }, SqlText = genText };
                        var genParamName = ParameterNameBuilderHelper.ColumnQueryName(pk.Key.ColumnName, entityMap.TableAlias);

                        PropertyAccessor pInfo;
                        if (getSetInfo.Properties.TryGetValue(pk.Key.PropertyName, out pInfo))
                        {
                            KeyGenOperationInfo genKeyOper = new KeyGenOperationInfo()
                            {
                                Entity = entity,
                                PropertyName = pk.Key.PropertyName,
                                PropertyType = pInfo.PropertyType,
                                Operation = genOper,
                                Priority = priority
                            };

                            keygenerationOperations.Add(genParamName, genKeyOper);
                        }
                    }
                }
            }

            return keygenerationOperations;
        }

        /// <summary>
        /// Builds the insert SQL.
        /// </summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="entityMap">The entity map.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="recursive"></param>
        /// <returns></returns>
        public BatchSqlOperation BuildInsertSql<TEntity>(EntityMap entityMap, TEntity entity, bool recursive)
        {
            BatchSqlOperation operation = new BatchSqlOperation() { Priority = SqlOperationPriority.Medium };
            //Dictionary<string, PropertyQueryParam> neededParams = new Dictionary<string, PropertyQueryParam>();
            BuildInsertSql(entity, entityMap, typeof(TEntity), null, null, null, operation, recursive, 0, -1);

            return operation;
        }

        void BuildInsertSql
        (
            object entity,
            EntityMap entityMap,
            Type entityType,

            object parentEntity,
            EntityMap parentEntityMap,
            Type parentEntityType,
            BatchSqlOperation batchOperation,

            bool recursive,
            int recursionLevel = 0,
            int rootRecursionLevel = 0
         )
        {
            EntityMap baseEntMap = null;
            Dictionary<string, KeyGenOperationInfo> keygenerationOperations = new Dictionary<string, KeyGenOperationInfo>();
            bool isSubclass = entityMap.IsSubClass;
            InsertSqlBuilderOld baseInsertSqlBuilderOld = null;
            BatchSqlOperation operation = null;

            EntityAccessor entGetSets = EntityAccessorStore.GetEntityAccessor(entityType, entityMap);

            if (isSubclass)
            {
                //get base class first
                baseEntMap = entityMap.Parent.GetEntityMap(entityMap.Extends);
                baseInsertSqlBuilderOld = new InsertSqlBuilderOld(dialect, baseEntMap, recursionLevel, rootRecursionLevel);
                keygenerationOperations = GeneratePksForInsert(entity, baseEntMap, entGetSets);

                var baseParamDictionary = InsertSqlBuilderOld.BuildInsertQueryParams(entity, entGetSets, baseEntMap, EntityAccessorStore, recursionLevel, rootRecursionLevel);
                SqlOperationInfo baseClassOperation = new SqlOperationInfo() { CommandType = SqlStatementType.Insert };
                baseClassOperation.SqlText = baseInsertSqlBuilderOld.ToSqlString();
                List<QueryParam> baseParameters = new List<QueryParam>();
                baseParameters.AddRange(baseParamDictionary.Values);
                baseClassOperation.Parameters = baseParameters;
                operation = new BatchSqlOperation() { Priority = SqlOperationPriority.Low };

                batchOperation.Operations.Add(baseClassOperation);
                batchOperation.Priority = SqlOperationPriority.Medium;
                batchOperation.SubOperations.Add(operation);
            }
            else
            {
                keygenerationOperations = GeneratePksForInsert(entity, entityMap, entGetSets);
                operation = batchOperation;
                operation.Priority = SqlOperationPriority.Medium;
            }

            InsertSqlBuilderOld entInsertSqlBuilderOld = new InsertSqlBuilderOld(dialect, entityMap, recursionLevel, rootRecursionLevel);

            var paramDictionary = InsertSqlBuilderOld.BuildInsertQueryParams(entity, entGetSets, entityMap, EntityAccessorStore, recursionLevel, rootRecursionLevel);
            SqlOperationInfo operationInfo = new SqlOperationInfo() { CommandType = SqlStatementType.Insert };
            operationInfo.SqlText = entInsertSqlBuilderOld.ToSqlString();
            List<QueryParam> parameters = new List<QueryParam>();
            parameters.AddRange(paramDictionary.Values);
            operationInfo.Parameters = parameters;
            operation.Operations.Add(operationInfo);

            if (keygenerationOperations.Count > 0)
            {

                if (isSubclass)
                {
                    batchOperation.KeyGenerationOperations = keygenerationOperations;
                    batchOperation.Priority = SqlOperationPriority.High;
                }
                else
                {
                    operation.KeyGenerationOperations = keygenerationOperations;
                    operation.Priority = SqlOperationPriority.High;
                }
            }

            if (recursive)
            {
                rootRecursionLevel++;
                foreach (var rel in entityMap.Relations)
                {
                    if (rel.RelationType == RelationshipType.ManyToOne)
                        continue;

                    else if (rel.RelationType == RelationshipType.OneToMany)
                    {
                        PropertyAccessor pInfo;
                        if (entGetSets.Properties.TryGetValue(rel.PropertyName, out pInfo))
                        {
                            var colGetter = pInfo.GetMethod(entity);

                            if ((colGetter != null) && (colGetter is System.Collections.IEnumerable))
                            {
                                var list = (System.Collections.IEnumerable)colGetter;
                                foreach (var o in list)
                                {
                                    if (o == null)
                                        continue;
                                    //get type
                                    var reltype = o.GetType();
                                    //get map
                                    var relmap = entityMap.Parent.GetEntityMap(reltype.FullName);
                                    BatchSqlOperation relOper = new BatchSqlOperation() { Priority = SqlOperationPriority.Low };
                                    operation.SubOperations.Add(relOper);
                                    BuildInsertSql(o, relmap, reltype, entity, entityMap, entityType, relOper, true, ++recursionLevel, rootRecursionLevel);
                                }
                            }
                        }
                    }
                    else if ((rel.RelationType == RelationshipType.ManyToMany) && rel.Inverse)
                    {
                        PropertyAccessor pInfo;
                        if (entGetSets.Properties.TryGetValue(rel.PropertyName, out pInfo))
                        {
                            var colGetter = pInfo.GetMethod(entity);
                            if (colGetter is System.Collections.IEnumerable)
                            {
                                var list = (System.Collections.IEnumerable)colGetter;
                                foreach (var mappedObject in list)
                                {
                                    if (mappedObject == null)
                                        continue;

                                    var reltype = mappedObject.GetType();
                                    var relMap = entityMap.Parent.GetEntityMap(reltype.FullName);
                                    //build insert statement
                                    SqlOperationInfo manyToManyOp = new SqlOperationInfo();
                                    Property mapRel = relMap.GetProperty(rel.ReferenceProperty);

                                    if (mapRel != null)
                                    {
                                        var paramName1 = InsertSqlBuilderOld.BuildParameterNameWithLevel(rel.MapColumn, entityMap.TableAlias, recursionLevel);
                                        var paramName2 = InsertSqlBuilderOld.BuildParameterNameWithLevel(rel.MapReferenceColumn, relMap.TableAlias, recursionLevel);
                                        manyToManyOp.SqlText = string.Format("INSERT INTO {0} ({1}, {2}) VALUES({3},{4})", rel.MapTableName, rel.MapColumn, rel.MapReferenceColumn, dialect.CreateParameterName(paramName1), dialect.CreateParameterName(paramName2));
                                        var param1Prop = entGetSets.Properties[mapRel.PropertyName];

                                        EntityAccessor mappedGetSet = EntityAccessorStore.GetEntityAccessor(reltype, relMap);

                                        var param2Prop = mappedGetSet.Properties[rel.ReferenceProperty];
                                        manyToManyOp.Parameters = new ParamHolder[] { new ParamHolder(paramName1, param1Prop.GetMethod, entity) { IsNullable = rel.IsNullable }, 
                                            new ParamHolder(paramName2, param2Prop.GetMethod, mappedObject) { IsNullable = mapRel.IsNullable } };

                                        var manyToManySubOp = new BatchSqlOperation() { Priority = SqlOperationPriority.Low, KeyGenerationOperations = new Dictionary<string, KeyGenOperationInfo>() };
                                        manyToManySubOp.Operations.Add(manyToManyOp);
                                        operation.SubOperations.Add(manyToManySubOp);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        #endregion

        /// <summary>
        /// Builds the update SQL.
        /// </summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="entityMap">The entity map.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="updateManyToManyRelation">if set to <c>true</c> [update many to many relation].</param>
        /// <returns></returns>
        public BatchSqlOperation BuildUpdateSql<TEntity>(EntityMap entityMap, TEntity entity, bool updateManyToManyRelation = false)
        {
            BatchSqlOperation operation = new BatchSqlOperation() { Priority = SqlOperationPriority.Medium };

            BuildUpdateSql(entity, entityMap, typeof(TEntity), null, null, null, operation, updateManyToManyRelation, 0, 0);

            return operation;

        }

        void BuildUpdateSql
       (
           object entity,
           EntityMap entityMap,
           Type entityType,

           object parentEntity,
           EntityMap parentEntityMap,
           Type parentEntityType,
           BatchSqlOperation batchOperation,

           bool recursive,
           int recursionLevel = 0,
           int rootRecursionLevel = 0
        )
        {
            EntityMap baseEntMap = null;
            UpdateSqlBuilderOld baseUpdateBuilderOld = null;
            BatchSqlOperation operation = null;
            bool isSubclass = entityMap.IsSubClass;

            var entGetSets = EntityAccessorStore.GetEntityAccessor(entityType, entityMap);

            if (isSubclass)
            {
                baseEntMap = entityMap.Parent.GetEntityMap(entityMap.Extends);
                baseUpdateBuilderOld = new UpdateSqlBuilderOld(dialect, baseEntMap, recursionLevel, rootRecursionLevel);

                var baseParamDictionary = UpdateSqlBuilderOld.BuildUpdateQueryParams(entity, entGetSets, baseEntMap, EntityAccessorStore, recursionLevel, rootRecursionLevel);
                SqlOperationInfo baseSqlOp = new SqlOperationInfo() { CommandType = SqlStatementType.Update };

                var whereCollection = UpdateSqlBuilderOld.BuildWhereStatementFromPrimaryKey(baseEntMap, dialect, recursionLevel);
                baseSqlOp.SqlText = baseUpdateBuilderOld.Where(whereCollection).ToSqlString();
                List<QueryParam> baseParameters = new List<QueryParam>();
                baseParameters.AddRange(baseParamDictionary.Values);
                baseSqlOp.Parameters = baseParameters;
                operation = new BatchSqlOperation() { Priority = SqlOperationPriority.Low };

                batchOperation.Operations.Add(baseSqlOp);
                batchOperation.Priority = SqlOperationPriority.Medium;
                batchOperation.SubOperations.Add(operation);
            }
            else
            {
                operation = batchOperation;
                operation.Priority = SqlOperationPriority.Medium;
            }

            var wheres = UpdateSqlBuilderOld.BuildWhereStatementFromPrimaryKey(entityMap, dialect, recursionLevel);
            UpdateSqlBuilderOld entUpdateSqlBuilderOld = new UpdateSqlBuilderOld(dialect, entityMap, recursionLevel, rootRecursionLevel);
            var paramDictionary = UpdateSqlBuilderOld.BuildUpdateQueryParams(entity, entGetSets, entityMap, EntityAccessorStore, recursionLevel, rootRecursionLevel);
            SqlOperationInfo operationInfo = new SqlOperationInfo { CommandType = SqlStatementType.Update };
            operationInfo.SqlText = entUpdateSqlBuilderOld.Where(wheres).ToSqlString();

            List<QueryParam> parameters = new List<QueryParam>();
            parameters.AddRange(paramDictionary.Values);
            operationInfo.Parameters = parameters;
            operation.Operations.Add(operationInfo);

            if (recursive)
            {
                foreach (var rel in entityMap.Relations)
                {
                    if (rel.RelationType == RelationshipType.ManyToMany) //&& rel.Inverse)
                    {
                        PropertyAccessor pInfo;

                        if (entGetSets.Properties.TryGetValue(rel.PropertyName, out pInfo))
                        {
                            var colGetter = pInfo.GetMethod(entity);
                            if ((colGetter != null) && (colGetter is System.Collections.IEnumerable))
                            {
                                //Console.WriteLine("generic type def: {0}", colGetter.GetType().GetGenericTypeDefinition());
                                //var xto = pInfo.PropertType == typeof(ITrackableCollection<>);
                                var genArgType = pInfo.PropertyType.GetGenericArguments().FirstOrDefault();

                                if (genArgType == null)
                                    continue;

                                if (colGetter is ITrackableCollection)
                                {
                                    var trackableCol = (ITrackableCollection)colGetter;

                                    Update_CreateManyToManySubOperations(entityMap, rel, genArgType, entGetSets, operation, entity, trackableCol.InsertedItems, recursionLevel, true);
                                    Update_CreateManyToManySubOperations(entityMap, rel, genArgType, entGetSets, operation, entity, trackableCol.DeletedItems, recursionLevel, false);
                                }
                            }
                        }
                    }
                }
            }

        }

        void Update_CreateManyToManySubOperations(EntityMap entityMap, Relation rel, Type reltype, EntityAccessor entGetSets, BatchSqlOperation operation, object entity, System.Collections.IEnumerable list, int recursionLevel, bool insert)
        {
            foreach (var mappedObject in list)
            {
                if (mappedObject == null)
                    continue;

                var relMap = entityMap.Parent.GetEntityMap(reltype.FullName);

                SqlOperationInfo manyToManyOp = new SqlOperationInfo();
                Property mapRel = relMap.GetProperty(rel.ReferenceProperty);

                if (mapRel != null)
                {
                    var paramName1 = InsertSqlBuilderOld.BuildParameterNameWithLevel(rel.MapColumn, entityMap.TableAlias, recursionLevel);
                    var paramName2 = InsertSqlBuilderOld.BuildParameterNameWithLevel(rel.MapReferenceColumn, relMap.TableAlias, recursionLevel);
                    string sqlText = string.Empty;

                    if (insert)
                    {
                        manyToManyOp.CommandType = SqlStatementType.Insert;
                        sqlText = string.Format("INSERT INTO {0} ({1}, {2}) VALUES({3},{4})", rel.MapTableName, rel.MapColumn, rel.MapReferenceColumn, dialect.CreateParameterName(paramName1), dialect.CreateParameterName(paramName2));
                    }
                    else
                    {
                        manyToManyOp.CommandType = SqlStatementType.Delete;
                        string.Format("DELETE FROM {0} WHERE {1} = {3} AND {2} = {4}", rel.MapTableName, rel.MapColumn, rel.MapReferenceColumn, dialect.CreateParameterName(paramName1), dialect.CreateParameterName(paramName2));
                    }

                    manyToManyOp.SqlText = sqlText;
                    var param1Prop = entGetSets.Properties[mapRel.PropertyName];

                    var mappedGetSet = EntityAccessorStore.GetEntityAccessor(reltype, relMap);

                    var param2Prop = mappedGetSet.Properties[rel.ReferenceProperty];
                    manyToManyOp.Parameters = new ParamHolder[] { new ParamHolder(paramName1, param1Prop.GetMethod, entity) { IsNullable = rel.IsNullable }, 
                                            new ParamHolder(paramName2, param2Prop.GetMethod, mappedObject) { IsNullable = mapRel.IsNullable } };

                    var manyToManySubOp = new BatchSqlOperation() { Priority = SqlOperationPriority.Low, KeyGenerationOperations = new Dictionary<string, KeyGenOperationInfo>() };
                    manyToManySubOp.Operations.Add(manyToManyOp);
                    operation.SubOperations.Add(manyToManySubOp);
                }
            }
        }

        /// <summary>
        /// Builds the delete SQL.
        /// </summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="entityMap">The entity map.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="cascade">if set to <c>true</c> cascade delete.</param>
        /// <returns></returns>
        public BatchSqlOperation BuildDeleteSql<TEntity>(EntityMap entityMap, TEntity entity, bool cascade)
        {
            BatchSqlOperation operation = new BatchSqlOperation() { Priority = SqlOperationPriority.Medium };
            BuildDeleteSql(entity, entityMap, typeof(TEntity), operation);
            return operation;
        }

        void BuildDeleteSql
       (
           object entity,
           EntityMap entityMap,
           Type entityType,
           BatchSqlOperation batchOperation
        )
        {
            EntityMap baseEntMap = null;
            var entGetSets = EntityAccessorStore.GetEntityAccessor(entityType, entityMap);

            bool isSubclass = entityMap.IsSubClass;

            var wheres = UpdateSqlBuilderOld.BuildWhereStatementFromPrimaryKey(entityMap, dialect, 0);
            DeleteSqlBuilder entDeleteSqlBuilder = new DeleteSqlBuilder(dialect, entityMap);
            var paramDictionary = DeleteSqlBuilder.BuildDeleteQueryParams(entity, entGetSets, entityMap, EntityAccessorStore);
            SqlOperationInfo operationInfo = new SqlOperationInfo { CommandType = SqlStatementType.Delete };
            operationInfo.SqlText = entDeleteSqlBuilder.Where(wheres).ToSqlString();

            List<QueryParam> parameters = new List<QueryParam>();
            parameters.AddRange(paramDictionary.Values);
            operationInfo.Parameters = parameters;
            batchOperation.Operations.Add(operationInfo);


            if (isSubclass)
            {
                baseEntMap = entityMap.Parent.GetEntityMap(entityMap.Extends);
                var baseDeleteBuilder = new DeleteSqlBuilder(dialect, baseEntMap);

                var baseParamDictionary = DeleteSqlBuilder.BuildDeleteQueryParams(entity, entGetSets, baseEntMap, EntityAccessorStore);
                SqlOperationInfo baseSqlOp = new SqlOperationInfo() { CommandType = SqlStatementType.Delete };

                var whereCollection = UpdateSqlBuilderOld.BuildWhereStatementFromPrimaryKey(baseEntMap, dialect, 0);
                baseSqlOp.SqlText = baseDeleteBuilder.Where(whereCollection).ToSqlString();
                List<QueryParam> baseParameters = new List<QueryParam>();
                baseParameters.AddRange(baseParamDictionary.Values);
                baseSqlOp.Parameters = baseParameters;
                var operation = new BatchSqlOperation() { Priority = SqlOperationPriority.Low };

                operation.Operations.Add(baseSqlOp);
                batchOperation.Priority = SqlOperationPriority.Medium;
                batchOperation.SubOperations.Add(operation);
            }
        }
    }
}
