using System;
using System.Linq;
using Goliath.Data;
using Goliath.Data.Mapping;
using Goliath.Data.DataAccess;
using Goliath.Data.Utils;

namespace Goliath.Data.Sql
{
    public class InsertSqlBuilder
    {
        readonly EntityAccessorStore entityAccessorStore = new EntityAccessorStore();

        public InsertSqlInfo Build<T>(T entity, ISession session, EntityMap entityMap) where T : class
        {
            Type entityType = typeof(T);

            if (entity == null)
                throw new ArgumentNullException("entity");

            if (session == null)
                throw new ArgumentNullException("session");

            if (entityMap == null)
                throw new ArgumentNullException("entityMap");

            var info = new InsertSqlInfo { TableName = entityMap.TableName };
            var entityAccessor = entityAccessorStore.GetEntityAccessor(entityType, entityMap);
            var dialect = session.SessionFactory.DbSettings.SqlDialect;
            var converterStore = session.SessionFactory.DbSettings.ConverterStore;

            if (entityMap.PrimaryKey != null)
            {
                foreach (var pk in entityMap.PrimaryKey.Keys)
                {
                    SqlOperationPriority priority;
                    if (!pk.KeyGenerator.IsDatabaseGenerated)
                    {
                        PropertyAccessor pinf;
                        var pkQueryParam = new QueryParam(ParameterNameBuilderHelper.QueryParamName(entityMap, pk.Key.Name));

                        if (!entityAccessor.Properties.TryGetValue(pk.Key.Name, out pinf))
                            throw new GoliathDataException("Property " + pk.Key.Name + " not found in entity.");

                        if (!pk.UnsavedValueProcessed)
                        {
                            pk.UnsavedValue = pk.GetUnsavedValue(pinf.PropertyType, converterStore);
                        }

                        var pkValue = pinf.GetMethod(entity);

                        if (pkValue == pk.UnsavedValue)
                        {
                            var generatedKey = pk.KeyGenerator.GenerateKey(dialect, entityMap, pk.Key.Name, out priority);
                            pinf.SetMethod(entity, generatedKey);
                            pkQueryParam.Value = generatedKey;
                        }
                        else
                        {
                            pkQueryParam.Value = pkValue;
                        }

                        info.Parameters.Add(pk.Key.ColumnName, pkQueryParam);
                        info.Columns.Add(pk.Key.ColumnName);

                    }
                    else
                    {
                        var keyGenSql = pk.KeyGenerator.GenerateKey(dialect, entityMap, pk.Key.Name, out priority) as string;

                        if (!string.IsNullOrWhiteSpace(keyGenSql))
                            info.DbKeyGenerateSql.Add(keyGenSql);
                    }
                }
            }

            foreach (var prop in entityMap)
            {
                if (prop.IsPrimaryKey)
                    continue;

                var rel = prop as Relation;
                if ((rel != null) && ((rel.RelationType != RelationshipType.ManyToOne) || rel.IsAutoGenerated))
                    continue;

                if (!info.Columns.Contains(prop.ColumnName))
                {
                    PropertyAccessor pinf;
                    if (!entityAccessor.Properties.TryGetValue(prop.Name, out pinf))
                        throw new GoliathDataException("Property " + prop.Name + " not found in entity.");

                    info.Columns.Add(prop.ColumnName);
                    var propVal = pinf.GetMethod(entity);
                    info.Parameters.Add(prop.ColumnName, new QueryParam(ParameterNameBuilderHelper.QueryParamName(entityMap, prop.Name), propVal));

                }
            }

            return info;
        }
    }
}
