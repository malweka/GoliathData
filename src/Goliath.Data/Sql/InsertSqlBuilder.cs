using System;
using System.Collections.Generic;
using System.Linq;
using Goliath.Data;
using Goliath.Data.Mapping;
using Goliath.Data.DataAccess;
using Goliath.Data.Utils;

namespace Goliath.Data.Sql
{
    /// <summary>
    /// 
    /// </summary>
    public class InsertSqlBuilder
    {
        readonly EntityAccessorStore entityAccessorStore = new EntityAccessorStore();

        /// <summary>
        /// Builds the specified entity.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="entity">The entity.</param>
        /// <param name="entityMap">The entity map.</param>
        /// <param name="session">The session.</param>
        /// <returns></returns>
        public InsertSqlExecutionList Build<T>(T entity, EntityMap entityMap, ISession session) where T : class
        {
            var executionList = new InsertSqlExecutionList();
            Type entityType = typeof(T);
            Build(entity, entityType, entityMap, executionList, session);
            return executionList;
        }

        /// <summary>
        /// Builds the specified entity.
        /// </summary>
        /// <param name="entity">The entity.</param>
        /// <param name="entityType">Type of the entity.</param>
        /// <param name="entityMap">The entity map.</param>
        /// <param name="executionList">The execution list.</param>
        /// <param name="session">The session.</param>
        /// <exception cref="System.ArgumentNullException">entity</exception>
        /// <exception cref="GoliathDataException">Property  + prop.Name +  not found in entity.</exception>
        public void Build(object entity, Type entityType, EntityMap entityMap, InsertSqlExecutionList executionList, ISession session)
        {
            if (entity == null)
                throw new ArgumentNullException("entity");

            if (session == null)
                throw new ArgumentNullException("session");

            if (entityMap == null)
                throw new ArgumentNullException("entityMap");

            var info = new InsertSqlInfo { TableName = entityMap.TableName };
            var entityAccessor = entityAccessorStore.GetEntityAccessor(entityType, entityMap);
            var dialect = session.SessionFactory.DbSettings.SqlDialect;
            var converterStore = session.SessionFactory.DbSettings.ConverterStore;

            if (entityMap.PrimaryKey != null)
            {
                ProcessPrimaryKey(entity, entityType, entityMap, info, entityAccessor, executionList, session);
            }

            foreach (var prop in entityMap)
            {
                if (prop.IsPrimaryKey)
                    continue;

                var rel = prop as Relation;
                if ((rel != null) && ((rel.RelationType != RelationshipType.ManyToOne) || rel.IsAutoGenerated))
                    continue;

                var paramName = ParameterNameBuilderHelper.QueryParamName(entityMap, prop.Name);
                if (!info.Columns.ContainsKey(paramName))
                {
                    PropertyAccessor pinf;
                    if (!entityAccessor.Properties.TryGetValue(prop.Name, out pinf))
                        throw new GoliathDataException("Property " + prop.Name + " not found in entity.");

                    info.Columns.Add(paramName, prop.ColumnName);
                    var propVal = pinf.GetMethod(entity);
                    info.Parameters.Add(paramName, new QueryParam(paramName, propVal));
                }
            }

            executionList.ExcuteStatement(session,info);
        }

        void ProcessPrimaryKey(object entity, Type entityType, EntityMap entityMap, InsertSqlInfo info, EntityAccessor entityAccessor, InsertSqlExecutionList executionList, ISession session)
        {
            var dialect = session.SessionFactory.DbSettings.SqlDialect;
            var converterStore = session.SessionFactory.DbSettings.ConverterStore;

            foreach (var pk in entityMap.PrimaryKey.Keys)
            {
                var rel = pk.Key as Relation;
                if(rel != null)
                {
                    var relEntMap = session.SessionFactory.DbSettings.Map.GetEntityMap(rel.ReferenceEntityName);
                    var paramName = ParameterNameBuilderHelper.QueryParamName(relEntMap, rel.ReferenceProperty);
                    var pkQueryParam = new QueryParam(paramName);
                    info.Parameters.Add(paramName, pkQueryParam);
                    info.Columns.Add(paramName, pk.Key.ColumnName);
                    Build(entity, entityType, relEntMap, executionList, session);
                    continue;
                }

                SqlOperationPriority priority;
                if (!pk.KeyGenerator.IsDatabaseGenerated)
                {
                    info.DelayExecute = true;
                    string paramName = ParameterNameBuilderHelper.QueryParamName(entityMap, pk.Key.Name);
                    PropertyAccessor pinf;
                    var pkQueryParam = new QueryParam(paramName);

                    if (!entityAccessor.Properties.TryGetValue(pk.Key.Name, out pinf))
                        throw new GoliathDataException("Property " + pk.Key.Name + " not found in entity.");

                    if (!pk.UnsavedValueProcessed)
                    {
                        pk.UnsavedValue = pk.GetUnsavedValue(pinf.PropertyType, converterStore);
                    }

                    var pkValue = pinf.GetMethod(entity);

                    if (pkValue == pk.UnsavedValue)
                    {
                        var generatedKey = pk.KeyGenerator.GenerateKey(dialect, entityMap, pk.Key.Name, out priority);
                        pinf.SetMethod(entity, generatedKey);
                        pkQueryParam.Value = generatedKey;
                    }
                    else
                    {
                        pkQueryParam.Value = pkValue;
                    }

                    info.Parameters.Add(paramName, pkQueryParam);
                    info.Columns.Add(paramName, pk.Key.ColumnName);

                }
                else
                {
                    var keyGenSql = pk.KeyGenerator.GenerateKey(dialect, entityMap, pk.Key.Name, out priority) as string;

                    if (!string.IsNullOrWhiteSpace(keyGenSql))
                        info.DbKeyGenerateSql.Add(keyGenSql);
                }
            }
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public class InsertSqlExecutionList
    {
        readonly List<InsertSqlInfo> statements = new List<InsertSqlInfo>();
        public List<InsertSqlInfo> Statements { get { return statements; } }

        /// <summary>
        /// Excutes the statement.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="statement">The statement.</param>
        internal object ExcuteStatement(ISession session, InsertSqlInfo statement)
        {
            object value = null;

            if (!statement.DelayExecute)
            {
                //execute all
                var sql = statement.ToString(session.SessionFactory.DbSettings.SqlDialect);
                //TODO: execution code here
                statement.Processed = true;
            }

            Statements.Add(statement);

            return null;
        }

        public void Execute(ISession session)
        {
            //TODO: execute all statements here
        }
    }
}
