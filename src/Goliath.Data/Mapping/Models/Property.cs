using System;
using System.Text;
using System.Data;
using System.Runtime.Serialization;

namespace Goliath.Data.Mapping
{
    /// <summary>
    /// 
    /// </summary>
    [Serializable]
    [DataContract]
    public class Property : ConfigProperty
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Property"/> class.
        /// </summary>
        public Property() { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Property"/> class.
        /// </summary>
        /// <param name="columnName">Name of the column.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="dbType">Type of the db.</param>
        public Property(string columnName, string propertyName, DbType dbType)
        {
            ColumnName = columnName;
            PropertyName = propertyName;
            DbType = dbType;
        }

        /// <summary>
        /// Gets or sets a value indicating whether [lazy load].
        /// </summary>
        /// <value><c>true</c> if [lazy load]; otherwise, <c>false</c>.</value>
        [DataMember]
        public bool LazyLoad { get; set; }
        /// <summary>
        /// Gets or sets a value indicating whether [ignore on update].
        /// </summary>
        /// <value><c>true</c> if [ignore on update]; otherwise, <c>false</c>.</value>
        [DataMember]
        public bool IgnoreOnUpdate { get; set; }
        /// <summary>
        /// Gets or sets a value indicating whether this instance is complex type.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if this instance is complex type; otherwise, <c>false</c>.
        /// </value>
        [DataMember]
        public bool IsComplexType { get; set; }
        /// <summary>
        /// Gets or sets the name of the complex type.
        /// </summary>
        /// <value>The name of the complex type.</value>
        [DataMember]
        public string ComplexTypeName { get; set; }
        /// <summary>
        /// Gets or sets the type of the constraint.
        /// </summary>
        /// <value>The type of the constraint.</value>
        [DataMember]
        public ConstraintType ConstraintType { get; set; }
        /// <summary>
        /// Gets or sets the default value.
        /// </summary>
        /// <value>The default value.</value>
        [DataMember]
        public string DefaultValue { get; set; }
        /// <summary>
        /// Gets or sets the name of the constraint.
        /// </summary>
        /// <value>The name of the constraint.</value>
        [DataMember]
        public string ConstraintName { get; set; }
        /// <summary>
        /// Gets or sets the precision.
        /// </summary>
        /// <value>The precision.</value>
        [DataMember]
        public int Precision { get; set; }
        /// <summary>
        /// Gets or sets the scale.
        /// </summary>
        /// <value>The scale.</value>
        [DataMember]
        public int Scale { get; set; }


        /// <summary>
        /// Clones this instance.
        /// </summary>
        /// <returns></returns>
        public Property Clone()
        {
            Property prop = new Property();
            prop.LazyLoad = LazyLoad;
            prop.IgnoreOnUpdate = IgnoreOnUpdate;
            prop.IsComplexType = IsComplexType;
            prop.ComplexTypeName = ComplexTypeName;
            prop.ConstraintType = ConstraintType;
            prop.DefaultValue = DefaultValue;
            prop.ConstraintName = ConstraintName;
            prop.PropertyName = PropertyName;
            prop.ColumnName = ColumnName;
            prop.ClrType = ClrType;
            prop.DbType = DbType;
            prop.Errors = Errors;
            prop.Length = Length;
            prop.Precision = Precision;
            prop.Scale = Scale;
            prop.IsNullable = IsNullable;
            prop.IsIdentity = IsIdentity;
            prop.IsAutoGenerated = IsAutoGenerated;
            prop.IsUnique = IsUnique;
            prop.IsPrimaryKey = IsPrimaryKey;
            prop.SqlType = SqlType;

            return prop;
        }

        /// <summary>
        /// Gets the CLR type as string.
        /// </summary>
        /// <param name="entity">The entity.</param>
        /// <returns></returns>
        public virtual string GetClrTypeAsString(Goliath.Data.Providers.SqlDialect dialect,  EntityMap entity)
        {
            if (IsComplexType && (entity.Parent != null))
            {
                var complexT = entity.Parent.ComplexTypes[ComplexTypeName];
                if (complexT != null)
                {
                    return complexT.FullName;
                }
            }
            else
            {
                var clrType  = dialect.GetClrType(DbType, IsNullable);
                return ToPrintString(clrType);
            }

            throw new GoliathDataException(string.Format("Could not find CLR type for {0}.", PropertyName));
            //if (ClrType == null)
            //    return string.Empty;
            //else
            //{
                

            //    return ToPrintString(ClrType);
            //}
        }

        /// <summary>
        /// Prints the data convert method.
        /// </summary>
        /// <param name="methodPrefix">The method prefix.</param>
        /// <param name="entity">The entity.</param>
        /// <returns></returns>
        public string PrintDataConvertMethod(string methodPrefix, EntityMap entity)
        {
            string tstring;

            if (IsComplexType && (entity.Parent != null))
            {
                var complexT = entity.Parent.ComplexTypes[ComplexTypeName];
                if ((complexT != null) && complexT.IsEnum)
                {
                    return string.Format("ReadEnum<{0}>", complexT.FullName);
                }
            }

            if (ClrType.IsGenericType && ClrType.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                var args = ClrType.GetGenericArguments();
                tstring = ToPrintString(args[0], false);
                methodPrefix += "Nullable";
            }
            else
                tstring = ToPrintString(ClrType);
            return string.Format("{0}{1}", methodPrefix, Goliath.Data.Utils.Inflector.Pascalize(tstring));
        }

        string ToPrintString(Type type, bool nullable = false)
        {
            string print = type.Name;

            if (type.IsPrimitive || print.Equals("String") || print.Equals("Boolean"))
            {
                switch (type.Name.ToLower())
                {
                    case "int32":
                        print = "int";
                        break;
                    case "int64":
                        print = "long";
                        break;
                    case "int16":
                        print = "short";
                        break;
                    case "boolean":
                        print = "bool";
                        break;
                    case "single":
                        print = "float";
                        break;
                    default:
                        print = type.Name.ToLower();
                        break;
                }
            }

            else if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                var args = type.GetGenericArguments();
                return ToPrintString(args[0], true);
            }

            if (nullable)
                return string.Format("{0}?", print);

            return print;
        }

        internal  string GetQueryName(EntityMap map)
        {
            if (map == null)
                throw new ArgumentNullException("map");
            return ParameterNameBuilderHelper.ColumnQueryName(map.TableAlias, PropertyName);
        }

       

        /// <summary>
        /// Performs an implicit conversion from <see cref="Goliath.Data.Mapping.PrimaryKeyProperty"/> to <see cref="Goliath.Data.Mapping.Property"/>.
        /// </summary>
        /// <param name="pkProperty">The pk property.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Property(PrimaryKeyProperty pkProperty)
        {
            return pkProperty.Key;
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <param name="sqlDialect">The SQL dialect.</param>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public virtual string ToString(Providers.SqlDialect sqlDialect)
        {
            var txt = sqlDialect.TranslateToSqlStringType(this);
            return txt;
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return ColumnName;
        }
    }

}
